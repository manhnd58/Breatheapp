package application;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.effect.DropShadow;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.util.Duration;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class Tasks extends Application {

    public static ObservableList<LinkTasksAndCal> sharedTasks = FXCollections.observableArrayList();
    private static Stage mainStage;
    private ListView<LinkTasksAndCal> taskListView = new ListView<>(sharedTasks);
    private ProgressBar completionProgressBar = new ProgressBar(0);
    private Label completionLabel = new Label("0/0");
    private DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm dd/MM/yyyy", new java.util.Locale("vi", "VN"));
    private Calendar calendarApp;
    private VBox notificationArea;
    private static final String DB_URL = "jdbc:sqlserver://localhost:1433;databaseName=TaskManagerDB;encrypt=true;trustServerCertificate=true";
    private static final String DB_USER = "sa";
    private static final String DB_PASSWORD = "123456789";
    private static final DateTimeFormatter SQL_DATE_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    private static final ZoneId APP_ZONE_ID = ZoneId.of("GMT+7"); // Ép múi giờ GMT+7

    @Override
    public void start(Stage primaryStage) {
        mainStage = primaryStage;
        primaryStage.setTitle("Study Task Manager");

        // Đăng ký JDBC Driver
        try {
            Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
        } catch (ClassNotFoundException e) {
            showAlert("Driver Error", "JDBC Driver not found. Please add the Microsoft SQL Server JDBC Driver to your project.");
            e.printStackTrace();
            return;
        }

        // Kiểm tra kết nối cơ sở dữ liệu trước khi khởi tạo
        if (!testDatabaseConnection()) {
            // Thử tạo cơ sở dữ liệu nếu không tồn tại
            if (!createDatabase()) {
                showAlert("Critical Error", "Cannot connect to database or create TaskManagerDB. Please check your configuration and try again.");
                return;
            }
        }

        // Khởi tạo cơ sở dữ liệu
        initializeDatabase();

        // Tải tasks từ cơ sở dữ liệu
        try {
            sharedTasks.clear(); // Đảm bảo danh sách rỗng trước khi tải
            sharedTasks.addAll(getAllTasks());
        } catch (SQLException e) {
            showAlert("Database Error", "Failed to load tasks from database: " + e.getMessage());
            e.printStackTrace();
            sharedTasks = FXCollections.observableArrayList(); // Khởi tạo lại nếu lỗi
        }

        BorderPane mainLayout = new BorderPane();
        mainLayout.setPadding(new Insets(10));
        mainLayout.setBackground(new Background(new BackgroundFill(Color.web("#E0ECEF"), null, null)));

        mainLayout.setTop(createFilterBar());
        VBox centerLayout = new VBox(10);
        centerLayout.setPadding(new Insets(10));
        notificationArea = createNotificationArea();
        TextField searchField = new TextField();
        searchField.setPromptText("Search tasks...");
        searchField.setStyle("-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 8;");
        searchField.textProperty().addListener((obs, oldVal, newVal) -> {
            taskListView.setItems(sharedTasks.filtered(task ->
                    task.getTitle().toLowerCase().contains(newVal.toLowerCase()) ||
                    task.getDescription().toLowerCase().contains(newVal.toLowerCase())));
        });
        centerLayout.getChildren().addAll(searchField, notificationArea, taskListView, createProgressBarAndLabel());
        mainLayout.setCenter(centerLayout);

        taskListView.setCellFactory(param -> new TaskListCell());
        updateCompletionProgress();
        setupNotificationCheck();

        taskListView.setOnDragDetected(event -> {
            if (taskListView.getSelectionModel().getSelectedItem() == null) {
                return;
            }
            Dragboard db = taskListView.startDragAndDrop(TransferMode.MOVE);
            ClipboardContent content = new ClipboardContent();
            content.putString(String.valueOf(taskListView.getSelectionModel().getSelectedIndex()));
            db.setContent(content);
            event.consume();
        });

        taskListView.setOnDragOver(event -> {
            if (event.getGestureSource() != taskListView && event.getDragboard().hasString()) {
                event.acceptTransferModes(TransferMode.MOVE);
            }
            event.consume();
        });

        taskListView.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();
            boolean success = false;
            if (db.hasString()) {
                int draggedIndex = Integer.parseInt(db.getString());
                LinkTasksAndCal draggedTask = sharedTasks.get(draggedIndex);
                int dropIndex = taskListView.getItems().indexOf(event.getGestureTarget() instanceof TaskListCell ?
                        ((TaskListCell) event.getGestureTarget()).getItem() : draggedTask);

                if (dropIndex < 0 || dropIndex >= sharedTasks.size()) {
                    dropIndex = sharedTasks.size() - 1;
                }

                sharedTasks.remove(draggedIndex);
                sharedTasks.add(dropIndex, draggedTask);
                try {
                    saveTask(draggedTask);
                } catch (SQLException e) {
                    showAlert("Database Error", "Failed to save task order: " + e.getMessage());
                    e.printStackTrace();
                }
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });

        taskListView.setOnDragDone(DragEvent::consume);

        Scene scene = new Scene(mainLayout, 500, 600);
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.N && e.isControlDown()) {
                showAddEditTaskDialog(null);
            }
        });
        primaryStage.setScene(scene);
        primaryStage.setX(0);
        primaryStage.setOnCloseRequest(e -> mainStage = null);
        primaryStage.show();
    }

    // Kiểm tra kết nối cơ sở dữ liệu
    private boolean testDatabaseConnection() {
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {
            return true;
        } catch (SQLException e) {
            System.err.println("Database connection failed: " + e.getMessage());
            return false;
        }
    }

    // Tạo cơ sở dữ liệu TaskManagerDB nếu chưa tồn tại
    private boolean createDatabase() {
        String masterUrl = "jdbc:sqlserver://localhost:1433;databaseName=master;encrypt=true;trustServerCertificate=true";
        try (Connection conn = DriverManager.getConnection(masterUrl, DB_USER, DB_PASSWORD)) {
            Statement stmt = conn.createStatement();
            String sql = "IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'TaskManagerDB') " +
                        "CREATE DATABASE TaskManagerDB;";
            stmt.execute(sql);
            return true;
        } catch (SQLException e) {
            System.err.println("Failed to create database: " + e.getMessage());
            return false;
        }
    }

    // Khởi tạo bảng tasks trong MSSQL
    private void initializeDatabase() {
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {
            Statement stmt = conn.createStatement();
            String sql = """
                IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'tasks')
                CREATE TABLE tasks (
                    id NVARCHAR(36) PRIMARY KEY,
                    title NVARCHAR(255) NOT NULL,
                    description NVARCHAR(MAX),
                    start_time DATETIME,
                    end_time DATETIME,
                    duration BIGINT,
                    time_spent_hours INT,
                    time_spent_minutes INT,
                    recurrence NVARCHAR(50),
                    completed BIT NOT NULL DEFAULT 0,
                    priority NVARCHAR(50)
                );
                IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'idx_tasks_title')
                CREATE INDEX idx_tasks_title ON tasks (title);
                """;
            stmt.execute(sql);
        } catch (SQLException e) {
            showAlert("Database Error", "Failed to initialize database: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // Lưu hoặc cập nhật task vào cơ sở dữ liệu
    public void saveTask(LinkTasksAndCal task) throws SQLException {
        if (task.getTitle() == null || task.getTitle().trim().isEmpty()) {
            throw new SQLException("Task title cannot be null or empty.");
        }
        if (task.getTitle().length() > 255) {
            throw new SQLException("Task title exceeds maximum length of 255 characters.");
        }

        String sql = task.getId() == null || getTaskById(task.getId()) == null ?
                "INSERT INTO tasks (id, title, description, start_time, end_time, duration, time_spent_hours, time_spent_minutes, recurrence, completed, priority) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" :
                "UPDATE tasks SET title = ?, description = ?, start_time = ?, end_time = ?, duration = ?, time_spent_hours = ?, time_spent_minutes = ?, recurrence = ?, completed = ?, priority = ? WHERE id = ?";

        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            if (task.getId() == null || getTaskById(task.getId()) == null) {
                task.setId(java.util.UUID.randomUUID().toString());
                pstmt.setString(1, task.getId());
                pstmt.setString(2, task.getTitle());
                pstmt.setString(3, task.getDescription());
                pstmt.setString(4, task.getStartTime() != null ? task.getStartTime().format(SQL_DATE_FORMATTER) : null);
                pstmt.setString(5, task.getEndTime() != null ? task.getEndTime().format(SQL_DATE_FORMATTER) : null);
                pstmt.setLong(6, task.getDuration());
                pstmt.setInt(7, task.getTimeSpentHours());
                pstmt.setInt(8, task.getTimeSpentMinutes());
                pstmt.setString(9, task.getRecurrence());
                pstmt.setBoolean(10, task.isCompleted());
                pstmt.setString(11, task.getPriority());
            } else {
                pstmt.setString(1, task.getTitle());
                pstmt.setString(2, task.getDescription());
                pstmt.setString(3, task.getStartTime() != null ? task.getStartTime().format(SQL_DATE_FORMATTER) : null);
                pstmt.setString(4, task.getEndTime() != null ? task.getEndTime().format(SQL_DATE_FORMATTER) : null);
                pstmt.setLong(5, task.getDuration());
                pstmt.setInt(6, task.getTimeSpentHours());
                pstmt.setInt(7, task.getTimeSpentMinutes());
                pstmt.setString(8, task.getRecurrence());
                pstmt.setBoolean(9, task.isCompleted());
                pstmt.setString(10, task.getPriority());
                pstmt.setString(11, task.getId());
            }
            pstmt.executeUpdate();
        }
    }

    // Lấy tất cả tasks từ cơ sở dữ liệu
    private List<LinkTasksAndCal> getAllTasks() throws SQLException {
        List<LinkTasksAndCal> tasks = new ArrayList<>();
        String sql = "SELECT * FROM tasks";
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            while (rs.next()) {
                String startTimeStr = rs.getString("start_time");
                String endTimeStr = rs.getString("end_time");
                LinkTasksAndCal task = new LinkTasksAndCal(
                        rs.getString("title"),
                        startTimeStr != null && !startTimeStr.isEmpty() ? LocalDateTime.parse(startTimeStr, SQL_DATE_FORMATTER) : null,
                        endTimeStr != null && !endTimeStr.isEmpty() ? LocalDateTime.parse(endTimeStr, SQL_DATE_FORMATTER) : null,
                        rs.getBoolean("completed")
                );
                task.setId(rs.getString("id"));
                task.setDescription(rs.getString("description"));
                task.setDuration(rs.getLong("duration"));
                task.setTimeSpentHours(rs.getInt("time_spent_hours"));
                task.setTimeSpentMinutes(rs.getInt("time_spent_minutes"));
                task.setRecurrence(rs.getString("recurrence"));
                task.setPriority(rs.getString("priority"));
                tasks.add(task);
            }
        }
        return tasks;
    }

    // Lấy task theo id
    private LinkTasksAndCal getTaskById(String id) throws SQLException {
        String sql = "SELECT * FROM tasks WHERE id = ?";
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, id);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    String startTimeStr = rs.getString("start_time");
                    String endTimeStr = rs.getString("end_time");
                    LinkTasksAndCal task = new LinkTasksAndCal(
                            rs.getString("title"),
                            startTimeStr != null && !startTimeStr.isEmpty() ? LocalDateTime.parse(startTimeStr, SQL_DATE_FORMATTER) : null,
                            endTimeStr != null && !endTimeStr.isEmpty() ? LocalDateTime.parse(endTimeStr, SQL_DATE_FORMATTER) : null,
                            rs.getBoolean("completed")
                    );
                    task.setId(rs.getString("id"));
                    task.setDescription(rs.getString("description"));
                    task.setDuration(rs.getLong("duration"));
                    task.setTimeSpentHours(rs.getInt("time_spent_hours"));
                    task.setTimeSpentMinutes(rs.getInt("time_spent_minutes"));
                    task.setRecurrence(rs.getString("recurrence"));
                    task.setPriority(rs.getString("priority"));
                    return task;
                }
            }
        }
        return null;
    }

    // Xóa task khỏi cơ sở dữ liệu
    public void deleteTask(String id) throws SQLException {
        String sql = "DELETE FROM tasks WHERE id = ?";
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, id);
            pstmt.executeUpdate();
        }
    }

    private VBox createNotificationArea() {
        VBox notificationBox = new VBox(5);
        notificationBox.setPadding(new Insets(10));
        notificationBox.setBackground(new Background(new BackgroundFill(Color.web("#FFF3E0"), new CornerRadii(8), null)));
        notificationBox.setBorder(new Border(new BorderStroke(Color.web("#FFCA28"), BorderStrokeStyle.SOLID, new CornerRadii(8), new BorderWidths(1))));
        notificationBox.setVisible(false);
        return notificationBox;
    }

    private void setupNotificationCheck() {
        checkOverdueTasks();
        Timeline timeline = new Timeline(new KeyFrame(Duration.minutes(5), e -> checkOverdueTasks()));
        timeline.setCycleCount(Timeline.INDEFINITE);
        timeline.play();
    }

    private void checkOverdueTasks() {
        notificationArea.getChildren().clear();
        boolean hasOverdue = false;
        LocalDateTime now = LocalDateTime.now(APP_ZONE_ID); // Sử dụng múi giờ GMT+7
        for (LinkTasksAndCal task : sharedTasks) {
            if (task.getEndTime() != null && now.isAfter(task.getEndTime()) && !task.isCompleted()) {
                HBox notification = new HBox(10);
                Label message = new Label("Overdue: " + task.getTitle() + " (Due: " + dateTimeFormatter.format(task.getEndTime()) + ")");
                message.setFont(Font.font("Arial", 12));
                message.setTextFill(Color.web("#D32F2F"));
                Button actionButton = new Button("Edit");
                styleButton(actionButton, "#4C7C8A", "#FFFFFF", 4);
                actionButton.setOnAction(e -> showAddEditTaskDialog(task));
                notification.getChildren().addAll(message, actionButton);
                notificationArea.getChildren().add(notification);
                hasOverdue = true;
            }
        }
        notificationArea.setVisible(hasOverdue);
        if (hasOverdue && mainStage != null && !mainStage.isFocused()) {
            mainStage.requestFocus();
        }
    }

    private HBox createFilterBar() {
        HBox filterBar = new HBox(10);
        filterBar.setAlignment(Pos.CENTER_LEFT);
        filterBar.setPadding(new Insets(15));
        filterBar.setBackground(new Background(new BackgroundFill(Color.web("#4C7C8A"), null, null)));
        filterBar.setEffect(new DropShadow(10, 0, 2, Color.gray(0.1)));

        Label titleLabel = new Label("Task Manager");
        titleLabel.setFont(Font.font("Arial", FontWeight.BOLD, 20));
        titleLabel.setTextFill(Color.WHITE);

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        ComboBox<String> sortCombo = new ComboBox<>();
        sortCombo.getItems().addAll("Default", "By Title", "By Deadline", "By Priority");
        sortCombo.setValue("Default");
        styleComboBox(sortCombo);
        sortCombo.setOnAction(e -> sortTasks(sortCombo.getValue()));

        Button calendarButton = new Button("View Calendar");
        styleButton(calendarButton, "#4C7C8A", "#FFFFFF", 8);
        calendarButton.setOnAction(e -> showCalendar());

        Button addButton = new Button("+");
        addButton.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        addButton.setBackground(new Background(new BackgroundFill(Color.web("#4C7C8A"), new CornerRadii(50), null)));
        addButton.setTextFill(Color.WHITE);
        addButton.setPrefSize(30, 30);
        addButton.setAlignment(Pos.CENTER);
        addButton.setEffect(new DropShadow(5, 0, 1, Color.gray(0.2)));

        addButton.setOnMouseEntered(e -> {
            addButton.setBackground(new Background(new BackgroundFill(Color.web("#355B66"), new CornerRadii(50), null)));
            addButton.setScaleX(1.05);
            addButton.setScaleY(1.05);
        });
        addButton.setOnMouseExited(e -> {
            addButton.setBackground(new Background(new BackgroundFill(Color.web("#4C7C8A"), new CornerRadii(50), null)));
            addButton.setScaleX(1.0);
            addButton.setScaleY(1.0);
        });

        addButton.setOnAction(e -> showAddEditTaskDialog(null));

        filterBar.getChildren().addAll(titleLabel, spacer, sortCombo, calendarButton, addButton);
        return filterBar;
    }

    private void showCalendar() {
        if (Calendar.getCalendarStage() == null) {
            calendarApp = new Calendar();
            Stage calendarStage = new Stage();
            calendarApp.start(calendarStage);
        } else {
            Calendar.getCalendarStage().toFront();
        }
    }

    private HBox createProgressBarAndLabel() {
        HBox box = new HBox(10);
        box.setAlignment(Pos.CENTER_RIGHT);
        HBox.setHgrow(completionProgressBar, Priority.ALWAYS);

        completionProgressBar.setStyle("-fx-accent: #4C7C8A; -fx-background-color: #F5F8FA; -fx-background-radius: 4;");
        completionProgressBar.setPrefHeight(20);

        completionLabel.setFont(Font.font("Arial", 14));
        completionLabel.setTextFill(Color.web("#2D3E50"));

        box.getChildren().addAll(completionProgressBar, completionLabel);
        return box;
    }

    private void sortTasks(String sort) {
        ObservableList<LinkTasksAndCal> sortedTasks = taskListView.getItems();
        switch (sort) {
            case "By Title":
                sortedTasks.sort((t1, t2) -> t1.getTitle().compareToIgnoreCase(t2.getTitle()));
                break;
            case "By Deadline":
                sortedTasks.sort((t1, t2) -> {
                    LocalDateTime d1 = t1.getEndTime() != null ? t1.getEndTime() : LocalDateTime.MAX;
                    LocalDateTime d2 = t2.getEndTime() != null ? t2.getEndTime() : LocalDateTime.MAX;
                    return d1.compareTo(d2);
                });
                break;
            case "By Priority":
                sortedTasks.sort((t1, t2) -> {
                    int p1 = getPriorityValue(t1.getPriority());
                    int p2 = getPriorityValue(t2.getPriority());
                    return Integer.compare(p2, p1);
                });
                break;
            default:
                break;
        }
        taskListView.setItems(FXCollections.observableArrayList(sortedTasks));
    }

    private int getPriorityValue(String priority) {
        switch (priority) {
            case "High": return 3;
            case "Medium": return 2;
            case "Low": return 1;
            default: return 2;
        }
    }

    public void showAddEditTaskDialog(LinkTasksAndCal taskToEdit) {
        Stage dialogStage = new Stage();
        dialogStage.initModality(Modality.APPLICATION_MODAL);
        dialogStage.setTitle(taskToEdit == null ? "Add Task" : "Edit Task");

        TextField titleField = new TextField(taskToEdit != null ? taskToEdit.getTitle() : "");
        titleField.setFont(Font.font("Arial", 14));
        titleField.setPromptText("Enter task title");
        titleField.setStyle("-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 8;");
        titleField.focusedProperty().addListener((obs, oldVal, newVal) -> {
            titleField.setStyle(newVal ? "-fx-background-color: #F5F8FA; -fx-border-color: #4C7C8A; -fx-border-radius: 4; -fx-padding: 8;" :
                    "-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 8;");
        });

        TextArea descriptionArea = new TextArea(taskToEdit != null ? taskToEdit.getDescription() : "");
        descriptionArea.setFont(Font.font("Arial", 14));
        descriptionArea.setPromptText("Add your task description");
        descriptionArea.setStyle("-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 8;");
        descriptionArea.setPrefRowCount(3);
        descriptionArea.focusedProperty().addListener((obs, oldVal, newVal) -> {
            descriptionArea.setStyle(newVal ? "-fx-background-color: #F5F8FA; -fx-border-color: #4C7C8A; -fx-border-radius: 4; -fx-padding: 8;" :
                    "-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 8;");
        });

        DatePicker startDatePicker = new DatePicker(taskToEdit != null && taskToEdit.getStartTime() != null ? taskToEdit.getStartTime().toLocalDate() : null);
        Spinner<Integer> startHourSpinner = new Spinner<>(0, 23, taskToEdit != null && taskToEdit.getStartTime() != null ? taskToEdit.getStartTime().toLocalTime().getHour() : 0);
        Spinner<Integer> startMinuteSpinner = new Spinner<>(0, 59, taskToEdit != null && taskToEdit.getStartTime() != null ? taskToEdit.getStartTime().toLocalTime().getMinute() : 0);
        DatePicker endDatePicker = new DatePicker(taskToEdit != null && taskToEdit.getEndTime() != null ? taskToEdit.getEndTime().toLocalDate() : null);
        Spinner<Integer> endHourSpinner = new Spinner<>(0, 23, taskToEdit != null && taskToEdit.getEndTime() != null ? taskToEdit.getEndTime().toLocalTime().getHour() : 23);
        Spinner<Integer> endMinuteSpinner = new Spinner<>(0, 59, taskToEdit != null && taskToEdit.getEndTime() != null ? taskToEdit.getEndTime().toLocalTime().getMinute() : 59);

        startHourSpinner.setPrefWidth(80);
        startMinuteSpinner.setPrefWidth(80);
        endHourSpinner.setPrefWidth(80);
        endMinuteSpinner.setPrefWidth(80);
        startHourSpinner.setEditable(true);
        startMinuteSpinner.setEditable(true);
        endHourSpinner.setEditable(true);
        endMinuteSpinner.setEditable(true);
        styleSpinner(startHourSpinner);
        styleSpinner(startMinuteSpinner);
        styleSpinner(endHourSpinner);
        styleSpinner(endMinuteSpinner);

        addSpinnerValidation(startHourSpinner, 0, 23);
        addSpinnerValidation(startMinuteSpinner, 0, 59);
        addSpinnerValidation(endHourSpinner, 0, 23);
        addSpinnerValidation(endMinuteSpinner, 0, 59);

        Label deadlineLabel = new Label("Deadline");

        Spinner<Integer> durationSpinner = new Spinner<>(0, 1440, taskToEdit != null ? (int) taskToEdit.getDuration() : 0);
        durationSpinner.setPrefWidth(100);
        durationSpinner.setEditable(true);
        styleSpinner(durationSpinner);
        addSpinnerValidation(durationSpinner, 0, 1440);
        Label durationUnitLabel = new Label("mins");

        Spinner<Integer> timeSpentHoursSpinner = new Spinner<>(0, 23, taskToEdit != null ? taskToEdit.getTimeSpentHours() : 0);
        Spinner<Integer> timeSpentMinutesSpinner = new Spinner<>(0, 59, taskToEdit != null ? taskToEdit.getTimeSpentMinutes() : 0);
        timeSpentHoursSpinner.setPrefWidth(80);
        timeSpentMinutesSpinner.setPrefWidth(80);
        timeSpentHoursSpinner.setEditable(true);
        timeSpentMinutesSpinner.setEditable(true);
        styleSpinner(timeSpentHoursSpinner);
        styleSpinner(timeSpentMinutesSpinner);
        addSpinnerValidation(timeSpentHoursSpinner, 0, 23);
        addSpinnerValidation(timeSpentMinutesSpinner, 0, 59);
        Label timeSpentHoursLabel = new Label("hr");
        Label timeSpentMinutesLabel = new Label("mins");

        ComboBox<String> recurrenceCombo = new ComboBox<>();
        recurrenceCombo.getItems().addAll("Does not repeat", "Daily", "Weekly", "Monthly");
        recurrenceCombo.setValue(taskToEdit != null ? taskToEdit.getRecurrence() : "Does not repeat");
        styleComboBox(recurrenceCombo);

        ComboBox<String> priorityCombo = new ComboBox<>();
        priorityCombo.getItems().addAll("High", "Medium", "Low");
        priorityCombo.setValue(taskToEdit != null ? taskToEdit.getPriority() : "Medium");
        styleComboBox(priorityCombo);

        Button saveButton = new Button("Save");
        styleButton(saveButton, "#4C7C8A", "#FFFFFF", 8);
        Button cancelButton = new Button("Cancel");
        styleButton(cancelButton, "#4C7C8A", "#FFFFFF", 8);
        Button deleteButton = new Button("Delete task");
        styleButton(deleteButton, "#FF4C4C", "#FFFFFF", 8);
        deleteButton.setVisible(taskToEdit != null);

        saveButton.setOnAction(e -> {
            String title = titleField.getText().trim();
            if (title.isEmpty()) {
                showAlert("Error", "Please enter a task title.");
                return;
            }
            if (title.length() > 255) {
                showAlert("Error", "Task title cannot exceed 255 characters.");
                return;
            }
            if (taskToEdit == null && sharedTasks.stream().anyMatch(t -> t.getTitle().equalsIgnoreCase(title))) {
                showAlert("Error", "A task with this title already exists.");
                return;
            }

            LocalDateTime startTime = startDatePicker.getValue() != null ?
                    startDatePicker.getValue().atTime(startHourSpinner.getValue(), startMinuteSpinner.getValue()) : null;
            LocalDateTime endTime = endDatePicker.getValue() != null ?
                    endDatePicker.getValue().atTime(endHourSpinner.getValue(), endMinuteSpinner.getValue()) : null;

            if (startTime != null && endTime != null && endTime.isBefore(startTime)) {
                showAlert("Error", "End time cannot be before start time.");
                return;
            }

            LinkTasksAndCal task = taskToEdit != null ? taskToEdit : new LinkTasksAndCal(title, startTime, endTime, false);
            task.setTitle(title);
            task.setDescription(descriptionArea.getText());
            task.setStartTime(startTime);
            task.setEndTime(endTime);
            task.setDuration(durationSpinner.getValue());
            task.setTimeSpentHours(timeSpentHoursSpinner.getValue());
            task.setTimeSpentMinutes(timeSpentMinutesSpinner.getValue());
            task.setRecurrence(recurrenceCombo.getValue());
            task.setPriority(priorityCombo.getValue());

            try {
                saveTask(task);
                if (taskToEdit == null) {
                    sharedTasks.add(task);
                }
                updateCompletionProgress();
                checkOverdueTasks();
                if (startTime != null && calendarApp != null) {
                    calendarApp.setCurrentDate(startTime.toLocalDate());
                }
                dialogStage.close();
            } catch (SQLException ex) {
                showAlert("Database Error", "Failed to save task: " + ex.getMessage());
                ex.printStackTrace();
            }
        });

        cancelButton.setOnAction(e -> dialogStage.close());

        deleteButton.setOnAction(e -> {
            if (taskToEdit != null) {
                try {
                    deleteTask(taskToEdit.getId());
                    sharedTasks.remove(taskToEdit);
                    updateCompletionProgress();
                    checkOverdueTasks();
                    dialogStage.close();
                } catch (SQLException ex) {
                    showAlert("Database Error", "Failed to delete task: " + ex.getMessage());
                    ex.printStackTrace();
                }
            }
        });

        GridPane grid = new GridPane();
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new Insets(20));
        grid.setBackground(new Background(new BackgroundFill(Color.web("#F5F8FA"), null, null)));
        grid.setEffect(new DropShadow(10, 0, 2, Color.gray(0.2)));

        int row = 0;
        grid.addRow(row++, new Label("Title:"), titleField);
        grid.addRow(row++, new Label("Description:"), descriptionArea);
        grid.addRow(row++, new Label("Start:"), new HBox(5, startDatePicker, startHourSpinner, new Label(":"), startMinuteSpinner));
        grid.addRow(row++, deadlineLabel, new HBox(5, endDatePicker, endHourSpinner, new Label(":"), endMinuteSpinner));
        grid.addRow(row++, new Label("Duration:"), new HBox(5, durationSpinner, durationUnitLabel));
        grid.addRow(row++, new Label("Time spent:"), new HBox(5, timeSpentHoursSpinner, timeSpentHoursLabel, timeSpentMinutesSpinner, timeSpentMinutesLabel));
        grid.addRow(row++, new Label("Recurrence:"), recurrenceCombo);
        grid.addRow(row++, new Label("Priority:"), priorityCombo);
        grid.addRow(row++, deleteButton, new HBox(5, saveButton, cancelButton));

        GridPane.setColumnSpan(titleField, 2);
        GridPane.setColumnSpan(descriptionArea, 2);
        GridPane.setHalignment(saveButton, HPos.RIGHT);
        GridPane.setHalignment(cancelButton, HPos.RIGHT);
        GridPane.setHalignment(deleteButton, HPos.LEFT);

        for (int i = 0; i < grid.getChildren().size(); i++) {
            if (grid.getChildren().get(i) instanceof Label) {
                Label label = (Label) grid.getChildren().get(i);
                label.setFont(Font.font("Arial", 14));
                label.setTextFill(Color.web("#2D3E50"));
            }
        }

        Scene dialogScene = new Scene(grid);
        dialogStage.setScene(dialogScene);
        dialogStage.showAndWait();
    }

    private void addSpinnerValidation(Spinner<Integer> spinner, int min, int max) {
        TextField editor = spinner.getEditor();
        editor.textProperty().addListener((obs, oldValue, newValue) -> {
            try {
                int value = Integer.parseInt(newValue);
                if (value < min) {
                    spinner.getValueFactory().setValue(min);
                    editor.setText(String.valueOf(min));
                } else if (value > max) {
                    spinner.getValueFactory().setValue(max);
                    editor.setText(String.valueOf(max));
                }
            } catch (NumberFormatException e) {
                if (!newValue.isEmpty()) {
                    spinner.getValueFactory().setValue(spinner.getValueFactory().getValue());
                    editor.setText(String.valueOf(spinner.getValue()));
                }
            }
        });
        editor.setOnAction(e -> {
            try {
                int value = Integer.parseInt(editor.getText());
                spinner.getValueFactory().setValue(Math.min(max, Math.max(min, value)));
            } catch (NumberFormatException ex) {
                editor.setText(String.valueOf(spinner.getValue()));
            }
        });
    }

    private void updateCompletionProgress() {
        long completedCount = sharedTasks.stream().filter(LinkTasksAndCal::isCompleted).count();
        completionProgressBar.setProgress(sharedTasks.isEmpty() ? 0 : (double) completedCount / sharedTasks.size());
        completionLabel.setText(completedCount + "/" + sharedTasks.size());
        checkOverdueTasks();
    }

    void showAlert(String title, String content) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(content);
        alert.getDialogPane().setBackground(new Background(new BackgroundFill(Color.web("#F5F8FA"), null, null)));
        alert.getDialogPane().setEffect(new DropShadow(10, 0, 2, Color.gray(0.2)));
        alert.showAndWait();
    }

    public static Stage getMainStage() {
        return mainStage;
    }

    public static void main(String[] args) {
        launch(args);
    }

    private class TaskListCell extends ListCell<LinkTasksAndCal> {
        private final Label titleLabel = new Label();
        private final Label timeLabel = new Label();
        private final VBox content = new VBox(5);
        private final ContextMenu contextMenu = new ContextMenu();
        private final MenuItem editItem = new MenuItem("Edit");
        private final MenuItem duplicateItem = new MenuItem("Duplicate");
        private final MenuItem deleteItem = new MenuItem("Delete");
        private final MenuItem scheduleItem = new MenuItem("Schedule Task");

        public TaskListCell() {
            content.setPadding(new Insets(10));
            content.setBackground(new Background(new BackgroundFill(Color.web("#F5F8FA"), new CornerRadii(8), null)));
            content.setBorder(new Border(new BorderStroke(Color.web("#E0ECEF"), BorderStrokeStyle.SOLID, new CornerRadii(8), new BorderWidths(1))));
            content.setEffect(new DropShadow(5, 0, 1, Color.gray(0.1)));

            HBox header = new HBox(10, titleLabel);
            header.setAlignment(Pos.CENTER_LEFT);
            content.getChildren().addAll(header, timeLabel);

            content.setOnMouseEntered(e -> {
                content.setEffect(new DropShadow(10, 0, 2, Color.gray(0.2)));
                content.setScaleX(1.01);
                content.setScaleY(1.01);
            });
            content.setOnMouseExited(e -> {
                content.setEffect(new DropShadow(5, 0, 1, Color.gray(0.1)));
                content.setScaleX(1.0);
                content.setScaleY(1.0);
            });

            contextMenu.getItems().addAll(editItem, duplicateItem, deleteItem, scheduleItem);
            setOnMouseClicked(e -> {
                if (!isEmpty() && e.getButton() == MouseButton.SECONDARY) {
                    contextMenu.show(this, e.getScreenX(), e.getScreenY());
                } else {
                    contextMenu.hide();
                }
            });

            editItem.setOnAction(e -> showAddEditTaskDialog(getItem()));
            duplicateItem.setOnAction(e -> {
                LinkTasksAndCal original = getItem();
                if (original != null) {
                    LinkTasksAndCal newTask = new LinkTasksAndCal(original.getTitle() + " (Copy)", original.getStartTime(), original.getEndTime(), false);
                    newTask.setDescription(original.getDescription());
                    newTask.setDuration(original.getDuration());
                    newTask.setTimeSpentHours(original.getTimeSpentHours());
                    newTask.setTimeSpentMinutes(original.getTimeSpentMinutes());
                    newTask.setRecurrence(original.getRecurrence());
                    newTask.setPriority(original.getPriority());
                    try {
                        saveTask(newTask);
                        sharedTasks.add(newTask);
                        updateCompletionProgress();
                    } catch (SQLException ex) {
                        showAlert("Database Error", "Failed to duplicate task: " + ex.getMessage());
                        ex.printStackTrace();
                    }
                }
            });
            deleteItem.setOnAction(e -> {
                LinkTasksAndCal task = getItem();
                if (task != null) {
                    try {
                        deleteTask(task.getId());
                        sharedTasks.remove(task);
                        updateCompletionProgress();
                    } catch (SQLException ex) {
                        showAlert("Database Error", "Failed to delete task: " + ex.getMessage());
                        ex.printStackTrace();
                    }
                }
            });
            scheduleItem.setOnAction(e -> {
                LinkTasksAndCal task = getItem();
                if (task != null) {
                    showAddEditTaskDialog(task);
                }
            });

            setOnDragOver(event -> {
                if (event.getGestureSource() != this && event.getDragboard().hasString()) {
                    event.acceptTransferModes(TransferMode.MOVE);
                }
                event.consume();
            });

            setOnDragDropped(event -> {
                Dragboard db = event.getDragboard();
                boolean success = false;
                if (db.hasString()) {
                    int draggedIndex = Integer.parseInt(db.getString());
                    LinkTasksAndCal draggedTask = sharedTasks.get(draggedIndex);
                    int dropIndex = sharedTasks.indexOf(getItem());

                    sharedTasks.remove(draggedIndex);
                    sharedTasks.add(dropIndex, draggedTask);
                    try {
                        saveTask(draggedTask);
                        success = true;
                    } catch (SQLException ex) {
                        showAlert("Database Error", "Failed to reorder task: " + ex.getMessage());
                        ex.printStackTrace();
                    }
                }
                event.setDropCompleted(success);
                event.consume();
            });
        }

        @Override
        protected void updateItem(LinkTasksAndCal task, boolean empty) {
            super.updateItem(task, empty);
            if (empty || task == null) {
                setGraphic(null);
                setContextMenu(null);
            } else {
                titleLabel.setText(task.getTitle() + " [" + task.getPriority() + "]");
                titleLabel.setFont(Font.font("Arial", FontWeight.BOLD, 14));
                titleLabel.setTextFill(Color.web("#2D3E50"));

                String timeText = "";
                boolean isOverdue = task.getEndTime() != null && LocalDateTime.now(APP_ZONE_ID).isAfter(task.getEndTime()) && !task.isCompleted();
                if (task.getStartTime() != null && task.getEndTime() != null) {
                    timeText = dateTimeFormatter.format(task.getStartTime()) + " - " + dateTimeFormatter.format(task.getEndTime());
                } else if (task.getEndTime() != null) {
                    timeText = "Hết hạn: " + dateTimeFormatter.format(task.getEndTime());
                } else {
                    timeText = "No scheduled time";
                }
                timeLabel.setText(timeText);
                timeLabel.setFont(Font.font("Arial", 12));
                timeLabel.setTextFill(isOverdue ? Color.RED : Color.web("#2D3E50"));

                if (isOverdue) {
                    content.setBorder(new Border(new BorderStroke(Color.RED, BorderStrokeStyle.SOLID, new CornerRadii(8), new BorderWidths(2))));
                } else {
                    content.setBorder(new Border(new BorderStroke(Color.web("#E0ECEF"), BorderStrokeStyle.SOLID, new CornerRadii(8), new BorderWidths(1))));
                }

                setGraphic(content);
                setContextMenu(contextMenu);
            }
        }
    }

    private void styleButton(Button button, String bgColor, String textColor, double radius) {
        button.setFont(Font.font("Arial", 14));
        button.setBackground(new Background(new BackgroundFill(Color.web(bgColor), new CornerRadii(radius), null)));
        button.setTextFill(Color.web(textColor));
        button.setPadding(new Insets(8, 16, 8, 16));
        button.setEffect(new DropShadow(5, 0, 2, Color.gray(0.2)));

        button.setOnMouseEntered(e -> {
            button.setBackground(new Background(new BackgroundFill(Color.web("#355B66"), new CornerRadii(radius), null)));
            button.setScaleX(1.05);
            button.setScaleY(1.05);
        });
        button.setOnMouseExited(e -> {
            button.setBackground(new Background(new BackgroundFill(Color.web(bgColor), new CornerRadii(radius), null)));
            button.setScaleX(1.0);
            button.setScaleY(1.0);
        });
    }

    private void styleComboBox(ComboBox<?> comboBox) {
        comboBox.setStyle("-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 6;");
        comboBox.setPrefWidth(150);
        comboBox.focusedProperty().addListener((obs, oldVal, newVal) -> {
            comboBox.setStyle(newVal ? "-fx-background-color: #F5F8FA; -fx-border-color: #4C7C8A; -fx-border-radius: 4; -fx-padding: 6;" :
                    "-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 6;");
        });
    }

    private void styleSpinner(Spinner<?> spinner) {
        spinner.setStyle("-fx-background-color: #F5F8FA; -fx-border-color: #B0BEC5; -fx-border-radius: 4; -fx-padding: 6;");
        spinner.getEditor().setFont(Font.font("Arial", 14));
    }
}
